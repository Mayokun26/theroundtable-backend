import express from 'express';
import { dynamoDB, TableNames } from '../config/dynamodb';
import { ScanCommand, GetCommand, QueryCommand } from '@aws-sdk/lib-dynamodb';
import { logger } from '../utils/logger';
import { getRedisClient, isRedisEnabled } from '../config/redis';

export const characterRoutes = express.Router();

// Get all characters
characterRoutes.get('/', async (req, res) => {
  try {
    // Try to get from Redis cache first
    const redisClient = getRedisClient();
    const cacheKey = 'characters:all';
    
    if (isRedisEnabled() && redisClient) {
      const cachedData = await redisClient.get(cacheKey);
      if (cachedData) {
        logger.info('Returning characters from cache');
        return res.status(200).json(JSON.parse(cachedData));
      }
    }
    
    // If not in cache or Redis is disabled, fetch from DynamoDB
    const command = new ScanCommand({
      TableName: TableNames.CHARACTERS,
    });
    
    try {
      const result = await dynamoDB.send(command);
      const characters = result.Items || [];
      
      const response = {
        status: 'success',
        message: 'Characters retrieved successfully',
        data: characters
      };
      
      // Cache the result for future requests (5 minutes)
      if (isRedisEnabled() && redisClient) {
        await redisClient.set(cacheKey, JSON.stringify(response), 'EX', 300);
      }
      
      return res.status(200).json(response);
    } catch (dbError) {
      logger.error('DynamoDB error:', dbError);
      
      // Fallback to mock data if database is unavailable
      logger.info('Falling back to mock character data');
      const mockCharacters = [
        { 
          id: '1', 
          name: 'Socrates',
          era: 'Ancient Greece',
          category: 'Philosopher',
          description: 'Classical Greek philosopher credited as one of the founders of Western philosophy.',
          traits: ['Wisdom', 'Ethics', 'Logic'],
          imageUrl: '/images/socrates.jpg'
        },
        { 
          id: '2', 
          name: 'Marie Curie',
          era: 'Modern Era',
          category: 'Scientist',
          description: 'Physicist and chemist who conducted pioneering research on radioactivity.',
          traits: ['Scientific', 'Dedicated', 'Pioneering'],
          imageUrl: '/images/marie-curie.jpg' 
        },
        { 
          id: '3', 
          name: 'Sun Tzu',
          era: 'Ancient China',
          category: 'Military Strategist',
          description: 'Chinese general, military strategist, writer, and philosopher known for "The Art of War".',
          traits: ['Strategic', 'Disciplined', 'Philosophical'],
          imageUrl: '/images/sun-tzu.jpg'
        }
      ];
      
      return res.status(200).json({
        status: 'success',
        message: 'List of characters returned (mock data)',
        data: mockCharacters
      });
    }
  } catch (error) {
    logger.error('Error retrieving characters:', error);
    return res.status(500).json({
      status: 'error',
      message: 'Failed to retrieve characters'
    });
  }
});

// Get character by ID
characterRoutes.get('/:id', async (req, res) => {
  const { id } = req.params;
  
  try {
    // Try to get from Redis cache first
    const redisClient = getRedisClient();
    const cacheKey = `characters:${id}`;
    
    if (isRedisEnabled() && redisClient) {
      const cachedData = await redisClient.get(cacheKey);
      if (cachedData) {
        logger.info(`Returning character ${id} from cache`);
        return res.status(200).json(JSON.parse(cachedData));
      }
    }
    
    // If not in cache or Redis is disabled, fetch from DynamoDB
    const command = new GetCommand({
      TableName: TableNames.CHARACTERS,
      Key: { id }
    });
    
    try {
      const result = await dynamoDB.send(command);
      const character = result.Item;
      
      if (!character) {
        // Fallback to mock data if character not found in database
        const mockCharacter = {
          id,
          name: id === '1' ? 'Socrates' : id === '2' ? 'Marie Curie' : 'Sun Tzu',
          era: id === '1' ? 'Ancient Greece' : id === '2' ? 'Modern Era' : 'Ancient China',
          category: id === '1' ? 'Philosopher' : id === '2' ? 'Scientist' : 'Military Strategist',
          description: 'This is a mock description for the character.',
          traits: ['Trait 1', 'Trait 2', 'Trait 3'],
          imageUrl: `/images/${id}.jpg`
        };
        
        const response = {
          status: 'success',
          message: 'Character retrieved (mock data)',
          data: mockCharacter
        };
        
        return res.status(200).json(response);
      }
      
      const response = {
        status: 'success',
        message: 'Character retrieved successfully',
        data: character
      };
      
      // Cache the result for future requests (5 minutes)
      if (isRedisEnabled() && redisClient) {
        await redisClient.set(cacheKey, JSON.stringify(response), 'EX', 300);
      }
      
      return res.status(200).json(response);
    } catch (dbError) {
      logger.error('DynamoDB error:', dbError);
      
      // Fallback to mock data if database is unavailable
      const mockCharacter = {
        id,
        name: id === '1' ? 'Socrates' : id === '2' ? 'Marie Curie' : 'Sun Tzu',
        era: id === '1' ? 'Ancient Greece' : id === '2' ? 'Modern Era' : 'Ancient China',
        category: id === '1' ? 'Philosopher' : id === '2' ? 'Scientist' : 'Military Strategist',
        description: 'This is a mock description for the character.',
        traits: ['Trait 1', 'Trait 2', 'Trait 3'],
        imageUrl: `/images/${id}.jpg`
      };
      
      return res.status(200).json({
        status: 'success',
        message: 'Character retrieved (mock data)',
        data: mockCharacter
      });
    }
  } catch (error) {
    logger.error(`Error retrieving character ${id}:`, error);
    return res.status(500).json({
      status: 'error',
      message: 'Failed to retrieve character'
    });
  }
});
